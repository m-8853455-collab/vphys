<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VPhys â€“ The Virtual Physics Lab</title>

<style>
body { font-family: Arial, sans-serif; margin:0; background:#eef2f7; }
header { background:#1e3a8a; color:white; text-align:center; padding:20px; }
.container { display:flex; gap:20px; margin:20px; }
section { background:white; padding:20px; border-radius:8px; }
.controls { width:340px; }
canvas { border:1px solid black; background:#e6f7fb; touch-action:none; }
button {
    background:#1e3a8a; color:white;
    border:none; border-radius:5px;
    padding:8px 14px; margin-top:6px; cursor:pointer;
}
button.secondary { background:#555; }
footer { background:#1e3a8a; color:white; text-align:center; padding:10px; }
</style>
</head>

<body>

<header>
<h1>VPhys</h1>
<p>The Virtual Physics Lab</p>
</header>

<div class="container">

<section>
<canvas id="sim" width="600" height="350"></canvas>
</section>

<section class="controls">

<h3>Projectile Inputs</h3>

<p>Initial speed u (m/s)</p>
<input type="number" id="u" value="20">

<p>Launch angle Î¸ (Â°)</p>
<input type="number" id="theta" value="45">

<p>Platform height h (m)</p>
<input type="number" id="platformH" value="5">

<p>Environment</p>
<select id="env">
    <option value="9.8">Earth</option>
    <option value="1.62">Moon</option>
</select>

<button onclick="launch()">â–¶ Start</button>
<button class="secondary" onclick="reset()">ðŸ”„ Reset</button>

<hr>

<h3>Zoom</h3>
<button onclick="zoomIn()">âž• Zoom In</button>
<button onclick="zoomOut()">âž– Zoom Out</button>

<hr>

<h3>Results</h3>
<p>t = <span id="time">â€“</span> s</p>
<p>Sx = <span id="sx">â€“</span> m</p>
<p>Sy = <span id="sy">â€“</span> m</p>
<p>Vx = <span id="vx">â€“</span> m/s</p>
<p>Vy = <span id="vy">â€“</span> m/s</p>
<p>v = <span id="vr">â€“</span> m/s</p>

</section>
</div>

<footer>
&copy; 2026 VPhys â€“ The Virtual Physics Lab
</footer>

<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

const groundY = canvas.height - 20;
let scale = 5;

let platformHeight = 0;
let path = [];
let dragIndex = 0;
let dragging = false;
let animIndex = 0;
let animating = false;

/* ---------- ZOOM ---------- */
function zoomIn() { scale *= 1.2; draw(); }
function zoomOut() { scale /= 1.2; draw(); }

/* ---------- START ---------- */
function launch() {
    const u = +uInput.value;
    const thetaDeg = +thetaInput.value;
    const theta = thetaDeg * Math.PI/180;
    const g = +env.value;
    platformHeight = +platformH.value;

    const ux = u * Math.cos(theta);
    const uy = u * Math.sin(theta);

    path = [{x:0, y:platformHeight, ux, uy, t:0}];
    for (let t=0.05; t<30; t+=0.05) {
        const x = ux*t;
        const y = platformHeight + uy*t - 0.5*g*t*t;
        if (y < 0) break;
        path.push({x,y,ux,uy,t});
    }

    animIndex = 0;
    animating = true;
    dragging = false;
    animate();
}

/* ---------- ANIMATION ---------- */
function animate() {
    if (!animating) return;
    dragIndex = animIndex;
    draw();
    animIndex++;
    if (animIndex >= path.length) {
        animating = false;
        dragging = true;
        return;
    }
    requestAnimationFrame(animate);
}

/* ---------- DRAW ---------- */
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // ground
    ctx.fillStyle = "blue";
    ctx.fillRect(0, groundY, canvas.width, 5);

    // platform (sticks with ball)
    const platformY = groundY - platformHeight * scale;
    ctx.fillRect(0, platformY, 80 * scale/5, 5);

    // trajectory
    ctx.fillStyle = "black";
    path.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x*scale, groundY-p.y*scale, 2, 0, Math.PI*2);
        ctx.fill();
    });

    if (!path.length) return;

    const p = path[dragIndex];

    // ball
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(p.x*scale, groundY-p.y*scale, 6, 0, Math.PI*2);
    ctx.fill();

    const g = +env.value;
    const vy = p.uy - g*p.t;
    const vr = Math.sqrt(p.ux*p.ux + vy*vy);

    time.innerText = p.t.toFixed(2);
    sx.innerText = p.x.toFixed(2);
    sy.innerText = p.y.toFixed(2);
    vx.innerText = p.ux.toFixed(2);
    vy.innerText = vy.toFixed(2);
    vr.innerText = vr.toFixed(2);
}

/* ---------- DRAG AFTER ANIMATION ---------- */
canvas.addEventListener("pointerdown", ()=>{ if (!animating) dragging=true; });
canvas.addEventListener("pointerup", ()=> dragging=false);
canvas.addEventListener("pointermove", e=>{
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / scale;

    let closest = 0;
    path.forEach((p,i)=>{
        if (Math.abs(p.x-x) < Math.abs(path[closest].x-x)) closest=i;
    });
    dragIndex = closest;
    draw();
});

/* ---------- RESET ---------- */
function reset() {
    path = [];
    animating = false;
    dragging = false;
    draw();
}

/* ---------- INPUT REFERENCES ---------- */
const uInput = document.getElementById("u");
const thetaInput = document.getElementById("theta");
const platformH = document.getElementById("platformH");
const env = document.getElementById("env");
</script>

</body>
</html>
